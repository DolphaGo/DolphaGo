## Deployment

> 쿠버네티스가 어떻게 무중단 배포를 할 수 있을까?

배포 방법에는 다음과 같이 3가지 방법이 있다.

1. 이전 파드들을 모두 삭제하고, 새로운 파드를 등록한 뒤 트래픽을 옮기기

- 이 방법은 다음과 같은 문제가 있다.
- 이전 파드들을 삭제하고, 새 파드가 시작되는 동안 짧은 시간의 다운타임이 생기게 된다.
- 이 짧은 시간의 다운 타임을 허용한다면, 이는 파드를 업데이트 하는 가장 간단한 방법이 된다.

2. Blue & Green 배포
- 다운 타임을 발생시키지 않고 한번에 여러 버전의 애플리케이션 전환을 할 수 있는 방법
- 먼저 새 파드를 모두 기동한 후에 이전 파드들의 트래픽을 변경해주고, 기존 파드를 내리는 방법
- 잠시동안 동시에 2배의 파드가 실행되므로 더 많은 하드웨어 리소스가 필요하다.

3. 롤링 업데이트
- 파드를 단계별로 교체
- 이전 레플리케이션 컨트롤러(레플리카 셋)를 천천히 스케일 다운하고, 새 파드를 스케일 업해서 이를 수행한다.
- 파드 셀렉터에 이전 파드와 새 파드를 모두 포함하게 하여 요청을 두 파드 세트로 보낼 수 있다.
- 수동 롤링 업데이트는 오류가 발생하기 쉽다. (올바른 순서로 수 많은 명령어를 실행해서, 순차적으로 롤링을 진행해야 한다.)
- 그러나 쿠버네티스를 이용하면, 하나의 명령어로 롤링업데이트를 수행할 수 있다.
  - `kubectl rolling-update` {as is rs} {to be rs} --image={image path}
  - 즉, 교체할 레플리케이션 컨트롤러(레플리카 셋)를 알려주고, 새 레플리케이션컨트롤러(레플리카 셋)의 이름을 지정한 다음, 새로 교체할 이미지를 지정해주면 된다.
- 그러나 kubectl이라는 클라이언트로 쿠버네티스의 리소스가 변경이 일어난다는 점은 좋지 못하다.


> 동일한 이미지 태그로 업데이트 푸시하기
- 애플리케이션을 수정하고 동일한 이미지 태그로 푸시하는 것이 좋은 선택은 아니긴 하지만 개발 중에는 그럴 수 있다.
- 워커 노드에서 일단 이미지를 한 번 가져오면, 이미지는 노드에 저장되고, 동일한 이미지를 사용해 새 파드를 실행할 때 이미지를 다시 가져오지 않는다. (이것이 이미지를 가져오는 기본 정책이 된다.)
- 즉, 변경한 내용을 같은 이미지 태그로 푸시하면 이미지가 변경되지 않는다.
- 새 파드가 동일한 노드로 스케줄된 경우엔 kubelet은 이전 버전의 이미지를 실행한다.
- 이런 일이 일어나지 않길 원한다면, imagePullPolicy 속성을 `Always`로 변경해야 한다.
- 기본 imagePullPolicy는 이미지 태그에 따라 드랃.
- 컨테이너가 latest 태그를 명시적으로(latest를 명시적으로 지정하거나, 태그를 지정하지 않을 때) 참조하는 경우에 imagePullPolicy의 기본값은 Always이지만, 컨테이너가 다른 태그를 참조할 땐 기본 값은 IfNotPresent가 된다.
- 그래서 가장 좋은 방법은 이미지를 변경할 때마다 새로운 태그를 적용하는 것이다.


> 롤링업데이트가 진행되는 과정

- 서비스의 파드 셀렉터가 app=dolphago라고 가정, 그리고 기존 파드들은 app=dolphago, deployment=abc-123456라고 가정한다.
- 기존 레플리카셋의 셀렉터가 app=dolphago, deployment=abc-123456 이라서 기존 파드들과 묶여있는 상황.
- 그런데 새로운 레플리카셋이 app=dolphago, deployment=zxc-12345 가 된다면, 새로 생성되는 파드들의 레이블은 app=dolphago, deployment=zxc-12345가 생성될 것,
- 그러나 서비스에서는 파드 셀렉터가 app=dolphago이기 때문에 새로운 파드들에게도 트래픽이 전달될 수 있다.
- 루프를 반복하면서 기존 파드를 내리고, 새로운 파드를 올리는 과정을 반복한다.
- 서비스는 롤링업데이트 중의 요청의 이전 파드와 새로운 파드 모두에 전달할 수 있게 된다.
- kubectl이 롤링업데이트를 계속하면 새로운 파드에 대한 요청 비율이 점점 높아지기 시작한다.
- 모두 롤링업데이트가 되었다면, kubectl은 이전 레플리카셋을 삭제하고 롤링업데이트는 완료된다.


<br/>

> kubectl rolling-update를 더이상 사용하지 않는 이유?

- **롤링업데이트를 수행하는 것이 바로 kubectl 클라이언트라는 것 때문.**
- `--v 6`옵션을 주어서 자세한 로깅을 확인해보면 롤링업데이트의 주체가 kubectl이라는 것을 알 수 있다.
- 즉, 쿠버네티스 마스터 대신에 스케일링을 수행하는 주체가 kubectl이라는 것 때문이다.
- 서버가 아닌 클라이언트에서 업데이트 프로세스를 진행하는 것의 단점은, 롤링 업데이트를 수행하는 동안 네트워크 연결이 끊어진다면 업데이트 프로세스는 중간에 중단이 된다.
- 또한 rolling-update라는 것이 실제 명령을 나타내기 때문에 좋지 못한 이유고 사용하지 않는 이유이기도 하다.
- 쿠버네티스에게 의도하는 시스템의 상태를 선언하고, 쿠버네티스가 그것을 달성하기 위해 가장 좋은 방법을 찾아내어 그 상태에 달하는 것이 쿠버네티스를 사용하는 이유이고 본질이라고 했다.
- 그래서 이러한 이유로 배포를 하는데 있어서 가장 좋은 방법이라고 칭해지는 `디플로이먼트`라는 새로운 리소스를 도입하게 되었다.


## 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용
- 디플로이먼트를 생성하면 레플리카셋 리소스가 그 아래에 생성이 된다.
- 디플로이먼트를 사용하게 되면 실제 파드는 디플로이먼트가 아닌 레플리카셋에 의해 생성되고 관리된다.

- `kubectl create -f deployment.yaml --record`
- create를 사용할 땐 반드시 --record를 사용하라. revision history에 나중에 유용하기 때문이다.
- `kubectl get po` 를 통해 확인해보면 파드의 이름에 중간에 숫자가 섞인 것들을 확인할 수 있는데, 디플로이먼트는 이를 직접 관리하지 않는다. 이건 디플로이먼트와 파드 테플릿의 해시값을 의미하고, 레플리카셋이 이러한 파드를 관리한다는 것을 의미한다.
- 디플로이먼트는 파드 템플릿의 각 버전마다 하나씩 여러개의 레플리카셋을 만든다. 파드 템플릿의 해시값을 사용하면 **디플로이 먼트에서 지정된 버전의 파드 템플릿에 관해 항상 동일한 레플리카셋을 사용할 수 있게 된다.**


### 서비스로 파드 액세스
- 새 파드의 레이블이 서비스의 레이블 셀렉터와 일치하게 되므로 이전에 생성한 서비스를 사용해서 액세스 할 수 있게 된다.


## 디플로이먼트 업데이트
- 기존 방법의 단점
  - 이전에는 레플리케이션 컨트롤러를 사용해서 애플리케이션을 실행시켰으므로 kubectl `rolling-update`명령어로 직접 업데이트 지시를 했었다.
  - 심지어 롤링업데이트를 할 땐 기존 레플리케이션 컨트롤러를 대체할 새로운 레플리케이션 컨트롤러 이름도 지정해야 했다.
  - 프로세스가 끝나면 쿠버네티스는 그제서야 원본 레플리케이션 컨트롤러를 삭제했다.
  - 이 프로세스 동안 터미널을 열어두고 kubectl이 네트워크 이슈 없이 롤링 업데이트를 완료했는지 확인해야 했다.

- 지금 방법
  - 디플로이먼트 리소스에 정의된 파드 템플릿만 수정하면 쿠버네티스가 실제 시스템 상태를 리소스에 정의된 상태로 만드는 데 필요한 모든 단계를 수행한다.
  - 디플로이 파드 템플릿에서 새 이미지 태그를 참조해서 시스템이 의도하는 상태가 될 수 있도록 쿠버네티스에 맡기면 그만이다.

### 디플로이먼트 전략
- 디플로이먼트는 기본 RollingUpdate 전략을 취한다.
  - `Recreate`라는 전략이 있긴한데, 이건 한 번에 기존 모든 파드를 삭제하고, 새로운 파드를 만든다. 짧은 서비스 다운 타임이 발생한다.
- `RollingUpdate` 전략은 서비스 다운타임이 없도록 한다. 
- 트래픽이 동시에 버전에 나누어 들어가기 때문에 **애플리케이션에서 이전 버전과 새 버전을 동시에 실행할 수 있는 경우에만 이 전략을 사용해야 한다.**



cf) 참고 : 쿠버네티스의 기존 리소스 수정하기
- kubectl edit
  - 기본 편집기로 오브젝트의 매니페스트를 오픈한다. 변경 후 파일을 저장하고 편집기를 종료하면 오브젝트가 업데이트가 된다.
    - ex) kubectl edit deployment my-deployment
- kubectl patch
  - 오브젝트의 개별 속성을 수정한다.
    - ex) kubectl patch deployment my-deployment -p '{"spec": {"template": {"spec": {"containers" : [{"name": "nodejs", "image": "Dolphago/test:v2"}]}}}}'
- kubectl apply
  - 전체 yaml/json 파일의 속성 값을 적용해서 오브젝트를 수정한다. yaml/json 에 지정된 오브젝트가 아직 없으면 생성된다. 파일에는 리소스의 전체 정의가 포함되어야 한다.

- kubectl replace
  - yaml/json 파일로 오브젝트를 새 것으로 교체한다. apply 명령어와 달리 이 명령은 오브젝트가 있어야만 한다. 그렇지 않으면 오류를 출력한다.

- kubectl set image
  - 파드, 디플로이먼트, 잡 또는 레플리카셋에 정의된 컨테이너 이미지를 변경한다.
    - ex) kubectl set image deployment my-deployment nodejs=dolphago/test:v2






