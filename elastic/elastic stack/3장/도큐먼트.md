- [도큐먼트 CRUD](#도큐먼트-crud)
  - [도큐먼트 인덱싱](#도큐먼트-인덱싱)
  - [새로운 필드가 추가된 도큐먼트 인덱싱](#새로운-필드가-추가된-도큐먼트-인덱싱)
  - [데이터 타입을 잘못 입력한 도큐먼트 인덱싱](#데이터-타입을-잘못-입력한-도큐먼트-인덱싱)
  - [도큐먼트 읽기](#도큐먼트-읽기)
  - [도큐먼트 수정](#도큐먼트-수정)
  - [도큐먼트 삭제](#도큐먼트-삭제)
  - [벌크 데이터](#벌크-데이터)

# 도큐먼트 CRUD

- 도큐먼트는 반드시 하나의 인덱스에 포함되어야 한다.
- 엘라스틱서치에서 도큐먼트를 인덱스에 포함시키는 것을 인덱싱(indexing)이라고 한다.


## 도큐먼트 인덱싱

![](/images/2022-03-17-00-04-54.png)

- 존재하지 않았던 index2라는 인덱스를 생성하면서 동시에 index2 인덱스에 도큐먼트를 인덱싱합니다.
- index2는 인덱스 이름
- _doc은 엔드포인트 구분을 위한 예약어
- 숫자 1은 인덱싱할 도큐먼트의 고유 아이디

생성된 인덱스를 확인해보면 다음과 같다.
![](/images/2022-03-17-00-06-09.png)

- mappings에 age는 long 타입, gender와 name은 text 타입으로 필드가 지정됨
- 데이터 타입을 지정하지 않아도 엘라스틱 서치는 도큐먼트의 필드와 값을 보고 자동으로 지정하는데, 이를 **다이내믹 매핑**이라고 한다.


## 새로운 필드가 추가된 도큐먼트 인덱싱
![](/images/2022-03-17-00-24-19.png)

이번엔 country 필드가 추가되고, 기존에 있던 age, gender 필드는 사용하지 않으나 문제없이 인덱싱이 된다.
![](/images/2022-03-17-00-25-03.png)

## 데이터 타입을 잘못 입력한 도큐먼트 인덱싱

![](/images/2022-03-17-00-32-46.png)

- 우리는 기존에 age가 long으로 타입이 지정된 것을 확인할 수 있었다.
- 원래는 age를 실수(long) 타입으로 매핑했는데 여기서는 텍스트로 매핑을 했다.
- 원래 관계형 데이터베이스면 오류가 발생했겠지만, **스키마에 유연하게 대응하는 엘라스틱서치는 타입을 변환하여 저장한다.**

![](/images/2022-03-17-00-43-09.png)
- 매핑은 변환되지 않았다.
- JSON 파일에서는 age:5, age:"5" 처럼 데이터 타입을 크게 신경쓰지 않고 표현하는 경우가 흔한데, 엘라스틱서치는 혹시 모를 사용자 입력 실수를 고려해 자동으로 데이터 형변환을 진행한다.

- **숫자 필드에 문자열이 입력되면, 숫자로 변환을 시도한다**
  - ex) "age": "10" -> 10
- **정수 필드에 소수가 입력되면 소숫점 아래 자리를 무시한다.**
  - ex) "age": 10.0 -> 10

## 도큐먼트 읽기
- 도큐먼트 읽는 방법은 2가지가 있다.
  - 도큐먼트 아이디를 이용해 조회하는 방법
  - 쿼리 DSL을 이용하는 방법

> 도큐먼트 아이디를 이용하여 조회하기
![](/images/2022-03-17-00-48-44.png)

근데 실제 빅데이터 세계에서는 도큐먼트를 하나씩 읽진 않는다.

> search DSL 쿼리를 이용해서 도큐먼트를 읽어올 수 있다.

![](/images/2022-03-17-01-31-04.png)
이와 같이 하면, index2내의 모든 도큐먼트를 가져온다. 더 자세한 쿼리 방법은 추후 설명한다.

## 도큐먼트 수정
![](/images/2022-03-17-01-32-08.png)

- 기존 1번 도큐먼트의 나이가 변경되었다. 
- 사실 도큐먼트 업데이트를 위한 특별한 API가 있는 것은 아니다. 도큐먼트를 인덱싱하는 과정에서 같은 도큐먼트 아이디가 있으면 덮어쓰기가 되는 것처럼 보인다.


또한 update api를 이용해서 특정 도큐먼트의 값을 업데이트 할 수도 있다.
![](/images/2022-03-17-01-33-54.png)

그리고 이제 결과를 확인해보면 다음과 같이 name이 변경된 것을 확인할 수 있습니다.
![](/images/2022-03-17-01-37-56.png)

- 그러나 **엘라스틱서치 도큐먼트 수정 작업은 비용이 많이 들기 때문에 권장하지는 않습니다.**
- 특히, 엘라스틱서치를 로그 수집 용도로 사용한다면 개별 도큐먼트를 수정할 일은 거의 없습니다.
- 개별 도큐먼트 수정이 많은 작업이라면 엘라스틱 서치가 아닌 다른 데이터베이스를 이용하는 것이 좋겠습니다.

## 도큐먼트 삭제
- 특정 도큐먼트를 삭제하기 위해선 당연히 도큐먼트가 속한 인덱스 명과 도큐먼트 아이디를 알고 있어야 합니다.
![](/images/2022-03-17-01-47-14.png)
- 도큐먼트 수정과 마찬가지로 개별 도큐먼트 삭제 또한 비용이 많이 들어가는 작업이니 사용시에 유의해야할 것입니다.

## 벌크 데이터

- 데이터 CRUD를 할 때 REST API를 호출해 하나하나 도큐먼트를 요청하는 것보다, 벌크로 한 번에 요청하는 것이 효율적이다. REST API 콜 횟수를 줄여 성능을 높이는 것.

- bulk API는 도큐먼트 읽기는 지원하지 않고, 도큐먼트 **생성/수정/삭제**만 지원한다. 벌크 데이터 포맷을 보면 삭제(delete)만 한 줄로 작성하고, 나머지 작업들(index, create, update)은 두 줄로 작성된다. 각 줄 사이에는 쉼표 등 별도의 구분자가 없고, 라인 사이 공백(빈 줄)을 허용하지 않는다.
- JSON 문법처럼 보이나, 복수의 JSON 구조를 줄바꿈 문자열로 구분하는 NDJSON(Newline Delimited JSON) 형태다.
- 따라서 라인이나 쉼표 사용에 주의해야 한다.

![](/images/2022-03-17-03-05-50.png)

- index2 인덱스에 2개의 도큐먼트를 벌크 형태로 넣은 것이다.
![](/images/2022-03-17-03-15-32.png)

벌크 데이터를 파일 형태로 만들어서 적용하는 방법도 있다.
실제 현업에서는 파일로 만들어서 사용하는 방식이 더 실용적이다.
키바나 콘솔에서는 파일 불러오기를 할 수 없어서, curl을 이용해서 bulk api를 사용해보자.

일단 벌크 데이터를 파일로 만들어야 한다.

bulk_index2 라는 이름으로 파일을 만들자(이때 NDJSON으로 만들어야 한다)
```
{"index": {"_index" : "index2", "_id": "6"}}
{"name": "hong", "age": 30, "gender": "female"}
{"index": {"_index" : "index2", "_id": "7"}}
{"name": "choi", "age": 50, "gender": "male"}
```

위와 같이 벌크용 데이터를 만들고
```
curl -H "Content-Type: application/x-ndjson" -X POST localhost:9200/_bulk --data-binary "bulk_index2";
```
`localhost:9200`은 엘라스틱 서치가 동작하는 호스트 주소고, `/_bulk`는 bulk api를 호출하는 것. `--data-binary`는 POST 메서드에 우리가 만든 파일을 바이너리 형태로 전송해주는 파라미터다.

(그런데 나는 어째서인지, 책이 윈도우 기준이라 그런가 다음과 같은 에러가 나고 있다.)

```
{"error":{"root_cause":[{"type":"illegal_argument_exception","reason":"The bulk request must be terminated by a newline [\\n]"}],"type":"illegal_argument_exception","reason":"The bulk request must be terminated by a newline [\\n]"},"status":400}%  
```