# 색인(indexing) 이란

문서를 분석하고, 저장하는 과정을 색인이라고 정의합니다.

(어떤 문서를 분석하고, ES에 저장하는 모든 과정)

# 색인 과정

![](/images/2024-05-24-01-21-17.png)


# 색인 과정 이해하기


우선, 다음과 같이 1번 문서를 첫 번째 데이터 노드에 색인을 해달라는 요청을 했다고 가정하자.
![](/images/2024-05-24-01-23-49.png)

그렇다면, 다음과 같이 primary, replica 가 지정되어서 각각 색인이 될 것이다.
number_of_shards 의 기본값은 1이고, number_of_replicas 의 기본값도 1이기 때문이다.

![](/images/2024-05-24-01-24-18.png)


이번엔 2번 문서를 두 번째 데이터 노드에 색인 요청이 들어왔다고 가정해보자.

![](/images/2024-05-24-01-25-44.png)

**엘라스틱 서치는 클러스터로 구성되어 있기 때문에 어떤 노드에 요청을 해도 동일한 응답을 보장한다.**

이 데이터 노드(2번)는 저 문서를 저장하기 위한 프라이머리 샤드를 가지고 있지 않다.

![](/images/2024-05-24-01-26-45.png)

그래서 위와 같이 자기가 받은 요청을 첫 번째 노드로 요청을 다시 보낸다.
그리고 첫 번째 노드는 두 번째 노드로 다시 요청을 보낸다.

이거 어떤 문제점이 있을까?

문서를 2개를 넣었음에도, 3번째 노드에는 아무런 동작이 일어나지 않는다.
아무런 샤드가 없기 때문이다.

![](/images/2024-05-24-01-27-45.png)

색인을 통해 inverted index 를 만드는 작업이 있는데 cpu나 memory를 가장 많이 잡아먹는 작업이다.

데이터 노드가 3대지만 색인에 있어서는 1대만 있는거나 마찬가지이다.

이는 **클러스터로서의 이점을 전혀 살리지 못하는 상황** 입니다.

### **그래서 적절한 수의 샤드 개수를 설정하는 것이 성능에 큰 영향을 미칩니다.**

노드의 대수, 더 좋은 노드(스케일 업)도 방법일 수 있겠지만, 지금 현재 클러스터의 이점을 잘 사용하고 있는 지 먼저 체크해보는 것이 좋다. 더 많은 노드들이 색인에 참여하고 있는지 먼저 확인을 해보는 것이다.

![](/images/2024-05-24-01-29-46.png)

즉, number_of_shards: 3, replica 는 1이라고 가정을 하면 어떨까

다음과 같이 3개의 프라이머리 샤드가 만들어졌을 것이다.

![](/images/2024-05-24-01-30-19.png)

첫 번째 문서는 0번 샤드에 저장이 되어서 1번 데이터 노드가 색인 작업하고, 2번 데이터 노드로 복사하고, 2번째는 1번 샤드에 들어가서, 3번 노드로 복사된다.

만약 3번이 만약 1번 데이터 노드로 색인 요청이 들어온다면 어떨까

![](/images/2024-05-24-01-31-22.png)

1번 노드는 이 요청을 3번 노드로 옮기게 되고, 3번 노드는 색인 처리를 한 다음, 레플리카로 복사를 하는 작업을 한다.

모든 데이터 노드가 색인에 참여하고 있다.

좋아 보이는가?

***만약 이 상황에서 노드가 1대 더 추가된다고 가정해볼까?***

![](/images/2024-05-24-01-32-59.png)

샤드 개수가 고르게 분배되지 않기 때문에 용량 불균형이 일어날 수 있다.

샤드 하나당 10GB 라고 가정하자

![](/images/2024-05-24-01-59-46.png)

10, 20, 10, 20 GB 로 각각 불균형이 일어날 수 있다.

**데이터 노드를 늘렸는데, 왜 고르게 분배되지 않지?** 라는 운영 경험이 있는데, 그 원인은 샤드가 고르게 분배되지 않았기 때문이었다.


## 그렇다면, 적절한 샤드의 개수는...?

ES 공식 문서에도 sizing 이라는 문서가 있습니다.

- 처음부터 완벽한 샤드 배치 계획을 세울 순 없습니다.
- 배치계획 -> 테스트 -> 우리 서비스에 맞는 usecase 에 맞는 샤드 배치 계획을 완성시켜 나가는 것이 중요하다.

![](/images/2024-05-24-02-01-34.png)

하루에 100GB 로그를 30일간 저장하는 클러스터를 구성해야 하는 상황이라고 생각해보자.

프라이머리샤드, 레플리카샤드 각각 1개씩 즉, 샤드는 2개씩 있어야 하고

인덱스별 샤드의 최대 크기를 10GB로 설정하면,
인덱스 별 프라이머리 샤드의 개수는 10개가 될 것이고 레플리카 개수는 10개도 될 것이다.
이 때 데이터 노드를 10개로 설정하면, 데이터 노드당 가져야 할 디스크의 크기는 600GB

그러면, 데이터 노드 당 가져야 할 디스크의 크기는 600GB가 된다.
-> 데이터 노드의 장애를 대비해서 700GB 정도로 설정한다.

**성능에 문제가 있다면 샤드의 수를 늘리거나 데이터 노드를 스케일 아웃/업 하면서 최적의 수치를 찾아간다.**

데이터 노드를 보니 CPU가 남는 상황이라면? 샤드의 개수를 늘려서 더 처리량을 늘려볼 수 있겠다.
(기존에 10개 였다가 15개, 15개로 처리해도 괜찮네? 20대로 늘려보고, 이런식으로 휴리스틱하게 최적화하면 된다)


# 이번 강의에서 배운 내용

- 색인은 인덱스를 생성하고, 매핑을 확인하고, inverted index 를 생성하고 문서를 저장하는 일련의 과정을 의미합니다.
- **색인은 프라이머리 샤드에서 일어납니다.**
  - 레플리카에 복제되는 과정까지도 색인이라고 하는 경우도 있지만, 샤드의 역할에 대해 초점을 맞췄기 때문에
- number_of_shards의 기본 값은 1이기 때문에, 별도로 설정하지 않는다면, 클러스터로서의 이점을 살릴 수 없는 경우가 발생합닏자.
- 적절한 샤드의 개수는 색인 성능을 향상 시키는 데 많은 영향을 끼칩니다.